<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Rtos - 标签 - sulpc&#39;s blog</title>
        <link>https://sulpc.github.io/tags/rtos/</link>
        <description>Rtos - 标签 - sulpc&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Sat, 11 Jan 2025 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://sulpc.github.io/tags/rtos/" rel="self" type="application/rss+xml" /><item>
    <title>notos：一个基于C的无栈协程库</title>
    <link>https://sulpc.github.io/posts/2025-01-11-notos/</link>
    <pubDate>Sat, 11 Jan 2025 00:00:00 &#43;0000</pubDate>
    <author>suplc</author>
    <guid>https://sulpc.github.io/posts/2025-01-11-notos/</guid>
    <description><![CDATA[notos nos is not os notos不是os，只有一两百行代码，勉强算作一个库，核心实现也不依赖底层平台。notos不提供实时性保证，不区分优先级，只提供一种差不多能用的伪多任务并发协作机制。
notos最终要达到用起来类似os的效果，也就是能这样使用：
1 2 3 4 5 6 7 int main() { os_init(); os_task_create(task1, task_func1); os_task_create(task2, task_func1); os_start(); // unreachable } 每个任务函数要能这样去写，看上去都是一个无限的循环：
1 2 3 4 5 6 7 8 9 TASK(test_sleep) { int data = 0; while (true) { printf(&#34;%d\n&#34;, ++data); task_sleep(500); if (data == 10) task_exit(); } } 当然实际上，如果不利用底层平台的一些特性，实现真正的上下文切换（像常规OS那样），C函数不可能在函数体运行过程中突然跳出，转而从另一个函数中间的某个位置开始运行，后面又在某个时刻切回当前位置继续运行。
根据Coroutines in C中描述的一种trick，利用这几行代码，就可以实现一种近似的效果：
1 2 3 4 #define tco_init(bp) bp = 0; #define tco_begin(bp) switch(bp) { case 0: #define tco_yeild(bp) bp = __LINE__; return; case __LINE__: #define tco_end() } 可以写出这样的函数：]]></description>
</item>
</channel>
</rss>
